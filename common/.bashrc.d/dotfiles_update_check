#!/bin/bash
# Dotfiles background update checker with interactive notification support
# Uses only in-memory state management (no file writes)

# Function to create an interactive update dialog with profile selection
interactive_update_prompt() {
    local dotfiles_dir="$HOME/dotfiles"

    # macOS using AppleScript
    if command -v osascript &>/dev/null; then
        # Try to show dialog, check if it actually works
        response=$(osascript -e 'display dialog "Your dotfiles are out of date! Would you like to update now?" buttons {"No", "Yes"} default button "Yes" with title "Dotfiles Update Available"' 2>/dev/null | cut -d: -f2)

        # Check if osascript actually ran successfully
        if [ -z "$response" ]; then
            # Dialog failed to show
            return 2
        fi

        if [[ "$response" == "Yes" ]]; then
            # Perform the update
            cd "$dotfiles_dir" || return 1
            git pull
            stow -t ~ common

            # Second dialog: Ask about profile
            profile_response=$(osascript -e 'display dialog "Which profile would you like to stow?" buttons {"None", "Personal", "Work"} default button "None" with title "Select Dotfiles Profile"' 2>/dev/null | cut -d: -f2)

            case "$profile_response" in
                "Personal")
                    _switch_dotfiles_profile "personal"
                    ;;
                "Work")
                    _switch_dotfiles_profile "work"
                    ;;
                "None")
                    # Already stowed common, nothing more to do
                    ;;
            esac

            # Show completion notification
            osascript -e 'display notification "Dotfiles updated successfully! Run: source ~/.bashrc" with title "Update Complete"'

            # Reload the current shell
            source ~/.bashrc

            # Let user know they need to press enter to get prompt back
            echo -e "\033[0;32m✓ Dotfiles updated and configuration reloaded. Press Enter to continue.\033[0m"

            return 0
        fi
        return 1

    # Linux using notify-send with actions
    elif command -v notify-send &>/dev/null; then
        # Check if notify-send supports actions (usually requires a notification daemon like dunst or mako)
        if notify-send --help 2>&1 | grep -q -- '--action'; then
            # Send notification with Yes/No actions
            action=$(notify-send -u critical \
                --action="yes=Yes" \
                --action="no=No" \
                "Dotfiles Update Available" \
                "Your dotfiles are out of date! Update now?" 2>/dev/null)

            if [[ "$action" == "yes" ]]; then
                # Perform update
                cd "$dotfiles_dir" || return 1
                git pull
                stow -t ~ common

                # Ask about profile with another notification
                profile_action=$(notify-send \
                    --action="none=None" \
                    --action="personal=Personal" \
                    --action="work=Work" \
                    "Select Profile" \
                    "Which profile would you like to stow?" 2>/dev/null)

                case "$profile_action" in
                    "personal")
                        _switch_dotfiles_profile "personal"
                        ;;
                    "work")
                        _switch_dotfiles_profile "work"
                        ;;
                    *)
                        # Default to none/common only
                        ;;
                esac

                # Send completion notification
                notify-send "Update Complete" "Dotfiles updated! Run: source ~/.bashrc"

                # Reload the current shell
                source ~/.bashrc

                return 0
            fi
            return 1
        else
            # Fallback: notify-send doesn't support actions, just send notification
            notify-send -u critical "Dotfiles Update Available" "Update available! Run 'update-dotfiles' in your terminal to update."
            return 2
        fi

    # Fallback - no notification available
    else
        return 2
    fi
}

# Simple notification for non-critical alerts
send_notification() {
    local title="$1"
    local message="$2"

    if command -v osascript &>/dev/null; then
        osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || return 1
    elif command -v notify-send &>/dev/null; then
        notify-send "$title" "$message" 2>/dev/null || return 1
    else
        return 1
    fi
}

# Show terminal message (non-blocking)
show_terminal_update_message() {
    echo -e "\033[1;33m━━━ Dotfiles Update Available ━━━\033[0m"
    echo -e "\033[0;33mRun 'update-dotfiles' to update your configuration.\033[0m"
    echo ""
}

# Get time-based check decision (no files needed)
should_check_for_updates() {
    # If we've already checked in this shell session, don't check again
    if [ -n "$_DOTFILES_CHECK_COMPLETED" ]; then
        return 1
    fi

    # Always check (as long as it's the first time in this session)
    return 0
}

# Background update check function
background_dotfiles_check() {
    local dotfiles_dir="$HOME/dotfiles"

    # Don't run if dotfiles directory doesn't exist
    if [ ! -d "$dotfiles_dir/.git" ]; then
        return 0
    fi

    # Check if we should run the check
    if ! should_check_for_updates; then
        return 0
    fi

    # Mark that we're checking (for this shell session)
    export _DOTFILES_CHECK_COMPLETED=1

    # Run the check in background
    (
        cd "$dotfiles_dir" 2>/dev/null || exit 0

        # Fetch updates with timeout (if available)
        local fetch_cmd="env GIT_TERMINAL_PROMPT=0 git -c url.https://github.com/.insteadOf=git@github.com: fetch --no-tags --quiet"

        if command -v timeout &>/dev/null; then
            # Linux with timeout command
            fetch_result=$(timeout 10s $fetch_cmd 2>/dev/null)
            fetch_status=$?
        elif command -v gtimeout &>/dev/null; then
            # macOS with GNU timeout (from coreutils)
            fetch_result=$(gtimeout 10s $fetch_cmd 2>/dev/null)
            fetch_status=$?
        else
            # No timeout command, use background job with sleep
            ( $fetch_cmd 2>/dev/null ) &
            local fetch_pid=$!
            local count=0
            while kill -0 $fetch_pid 2>/dev/null && [ $count -lt 10 ]; do
                sleep 1
                count=$((count + 1))
            done
            if kill -0 $fetch_pid 2>/dev/null; then
                kill $fetch_pid 2>/dev/null
                fetch_status=124  # Timeout exit code
            else
                wait $fetch_pid
                fetch_status=$?
            fi
        fi

        if [ $fetch_status -eq 0 ]; then
            local local_head=$(git rev-parse HEAD 2>/dev/null)
            local remote_head=$(git rev-parse @{u} 2>/dev/null)

            if [ -n "$remote_head" ] && [ "$local_head" != "$remote_head" ]; then
                # Check if local is behind
                if ! git merge-base --is-ancestor "$remote_head" "$local_head" 2>/dev/null; then
                    # Export for child shells to know
                    export DOTFILES_UPDATE_PENDING=1

                    # Try interactive update prompt
                    interactive_update_prompt
                    local prompt_result=$?

                    if [ $prompt_result -eq 0 ]; then
                        # Success - update was performed
                        unset DOTFILES_UPDATE_PENDING
                    elif [ $prompt_result -eq 2 ]; then
                        # Notification completely failed (no GUI available or error)
                        # Show terminal message as fallback
                        show_terminal_update_message
                    fi
                    # If result is 1, user declined via GUI - notification worked, user chose not to update

                elif git merge-base --is-ancestor "$local_head" "$remote_head" 2>/dev/null; then
                    # Local is ahead - just notify once per session
                    if [ -z "$_DOTFILES_AHEAD_NOTIFIED" ]; then
                        export _DOTFILES_AHEAD_NOTIFIED=1
                        if ! send_notification "Dotfiles Out of Sync" "Your local dotfiles are ahead of remote."; then
                            echo -e "\033[0;33mNote: Your local dotfiles are ahead of remote.\033[0m"
                        fi
                    fi
                fi
            else
                # Up to date
                unset DOTFILES_UPDATE_PENDING
            fi
        fi
    ) &

    # Disown background job
    disown
}

# Manual update command
update-dotfiles() {
    local dotfiles_dir="$HOME/dotfiles"
    local original_dir="$(pwd)"

    if [ ! -d "$dotfiles_dir/.git" ]; then
        echo "Error: Dotfiles directory not found at $dotfiles_dir"
        return 1
    fi

    echo "Checking for updates..."
    cd "$dotfiles_dir" || return 1

    # Fetch first to see if there are updates
    if ! git fetch --no-tags --quiet; then
        echo "Failed to check for updates"
        cd "$original_dir" 2>/dev/null
        return 1
    fi

    local local_head=$(git rev-parse HEAD)
    local remote_head=$(git rev-parse @{u} 2>/dev/null)

    if [ "$local_head" == "$remote_head" ]; then
        echo "Already up to date!"
        unset DOTFILES_UPDATE_PENDING
        cd "$original_dir" 2>/dev/null
        return 0
    fi

    # Try GUI update first
    interactive_update_prompt
    local prompt_result=$?

    if [ $prompt_result -eq 0 ]; then
        unset DOTFILES_UPDATE_PENDING
        echo "Update complete! Configuration reloaded."
        cd "$original_dir" 2>/dev/null
        return 0
    fi

    # Fallback to terminal-based update flow
    echo "Updates are available. Would you like to update now? (y/n)"
    read -r response

    if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
        echo "Updating dotfiles..."
        git pull
        echo "Restowing common files..."
        stow -t ~ common

        echo "Which profile would you like to stow?"
        echo "  1) None (common only)"
        echo "  2) Personal"
        echo "  3) Work"
        echo -n "Enter choice [1-3]: "
        read -r choice

        case "$choice" in
            2)
                _switch_dotfiles_profile "personal"
                ;;
            3)
                _switch_dotfiles_profile "work"
                ;;
            *)
                # Default to none/common only
                ;;
        esac

        unset DOTFILES_UPDATE_PENDING

        # Send completion notification if available
        send_notification "Dotfiles Updated" "Your dotfiles have been successfully updated."

        echo "Update complete! Reloading configuration..."
        source ~/.bashrc
        echo "Configuration reloaded."
    else
        echo "Update cancelled."
    fi

    # Return to original directory
    cd "$original_dir" 2>/dev/null
}

# Force check command
check-dotfiles-now() {
    local dotfiles_dir="$HOME/dotfiles"
    local original_dir="$(pwd)"

    echo "Checking for dotfiles updates..."

    cd "$dotfiles_dir" 2>/dev/null || {
        echo "Error: Cannot access dotfiles directory"
        return 1
    }

    # Reset check state to force a check
    unset _DOTFILES_CHECK_COMPLETED

    # Fetch updates with proper timeout handling
    local fetch_cmd="env GIT_TERMINAL_PROMPT=0 git -c url.https://github.com/.insteadOf=git@github.com: fetch --no-tags --quiet"
    local fetch_status

    if command -v timeout &>/dev/null; then
        # Linux with timeout command
        timeout 10s $fetch_cmd 2>/dev/null
        fetch_status=$?
    elif command -v gtimeout &>/dev/null; then
        # macOS with GNU timeout (from coreutils)
        gtimeout 10s $fetch_cmd 2>/dev/null
        fetch_status=$?
    else
        # No timeout command, use background job with sleep
        ( $fetch_cmd 2>/dev/null ) &
        local fetch_pid=$!
        local count=0
        while kill -0 $fetch_pid 2>/dev/null && [ $count -lt 10 ]; do
            sleep 1
            count=$((count + 1))
        done
        if kill -0 $fetch_pid 2>/dev/null; then
            kill $fetch_pid 2>/dev/null
            fetch_status=124  # Timeout exit code
        else
            wait $fetch_pid
            fetch_status=$?
        fi
    fi

    if [ $fetch_status -eq 0 ]; then
        local local_head=$(git rev-parse HEAD 2>/dev/null)
        local remote_head=$(git rev-parse @{u} 2>/dev/null)

        if [ -n "$remote_head" ] && [ "$local_head" != "$remote_head" ]; then
            if ! git merge-base --is-ancestor "$remote_head" "$local_head" 2>/dev/null; then
                export DOTFILES_UPDATE_PENDING=1
                echo "Updates are available!"

                # Try interactive prompt
                interactive_update_prompt
                local prompt_result=$?

                if [ $prompt_result -eq 0 ]; then
                    unset DOTFILES_UPDATE_PENDING
                elif [ $prompt_result -eq 2 ]; then
                    show_terminal_update_message
                fi
            elif git merge-base --is-ancestor "$local_head" "$remote_head" 2>/dev/null; then
                echo "Your local dotfiles are ahead of remote."
            fi
        else
            echo "Your dotfiles are up to date!"
            unset DOTFILES_UPDATE_PENDING
        fi
    else
        echo "Failed to check for updates (network issue or timeout)"
    fi

    # Return to original directory
    cd "$original_dir" 2>/dev/null
}

# Check on shell startup (non-blocking)
if [ -z "$_DOTFILES_CHECK_STARTED" ]; then
    export _DOTFILES_CHECK_STARTED=1
    background_dotfiles_check
fi

# Note: DOTFILES_UPDATE_PENDING is only used as a marker for child shells
# Messages are only shown if notifications fail, not on every shell open
