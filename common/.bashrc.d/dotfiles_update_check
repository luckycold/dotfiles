#!/bin/bash
# Simplified dotfiles update checker

# Send notification about available updates
send_update_notification() {
    if command -v osascript &>/dev/null; then
        osascript -e 'display notification "Run update-dotfiles to update" with title "Dotfiles Update Available"' 2>/dev/null
    elif command -v notify-send &>/dev/null; then
        notify-send "Dotfiles Update Available" "Run 'update-dotfiles' to update" 2>/dev/null
    fi
}

# Background check for updates (runs once per shell session)
background_dotfiles_check() {
    # Only check once per shell session
    [ -n "$_DOTFILES_CHECKED" ] && return 0
    export _DOTFILES_CHECKED=1

    local dotfiles_dir="$HOME/dotfiles"
    [ ! -d "$dotfiles_dir/.git" ] && return 0

    # Run check in background
    (
        cd "$dotfiles_dir" 2>/dev/null || exit 0

        # Fetch with timeout
        if command -v timeout &>/dev/null; then
            timeout 10s git fetch --quiet 2>/dev/null
        elif command -v gtimeout &>/dev/null; then
            gtimeout 10s git fetch --quiet 2>/dev/null
        else
            git fetch --quiet 2>/dev/null
        fi

        # Check if behind remote
        if [ $? -eq 0 ]; then
            local local_head=$(git rev-parse HEAD 2>/dev/null)
            local remote_head=$(git rev-parse @{u} 2>/dev/null)

            if [ -n "$remote_head" ] && [ "$local_head" != "$remote_head" ]; then
                if ! git merge-base --is-ancestor "$remote_head" "$local_head" 2>/dev/null; then
                    send_update_notification
                fi
            fi
        fi
    ) &
    disown
}

# Manual update command
update-dotfiles() {
    local dotfiles_dir="$HOME/dotfiles"
    local original_dir="$(pwd)"

    [ ! -d "$dotfiles_dir/.git" ] && echo "Error: Dotfiles not found at $dotfiles_dir" && return 1

    cd "$dotfiles_dir" || return 1

    # Check for updates
    echo "Checking for updates..."
    git fetch --quiet || { echo "Failed to check for updates"; cd "$original_dir"; return 1; }

    local local_head=$(git rev-parse HEAD)
    local remote_head=$(git rev-parse @{u} 2>/dev/null)

    if [ "$local_head" = "$remote_head" ]; then
        echo "Already up to date!"
        cd "$original_dir"
        return 0
    fi

    # Pull updates
    echo "Pulling updates..."
    git pull || { echo "Failed to pull updates"; cd "$original_dir"; return 1; }

    # Restow common
    echo "Restowing common files..."
    stow -t ~ common

    # Ask for profile
    echo "Which profile would you like?"
    echo "  1) None (common only)"
    echo "  2) Personal"
    echo "  3) Work"
    echo -n "Enter choice [1-3]: "
    read -r choice

    case "$choice" in
        2)
            stow -D -t ~ work 2>/dev/null
            stow -t ~ personal
            echo "Applied personal profile"
            ;;
        3)
            stow -D -t ~ personal 2>/dev/null
            stow -t ~ work
            echo "Applied work profile"
            ;;
        *)
            stow -D -t ~ personal 2>/dev/null
            stow -D -t ~ work 2>/dev/null
            echo "Using common only"
            ;;
    esac

    # Ask to reload bashrc
    echo -n "Reload shell configuration? (y/n): "
    read -r reload

    if [[ "$reload" =~ ^[yY]$ ]]; then
        source ~/.bashrc
        echo "Configuration reloaded"
    fi

    cd "$original_dir"
}

# Run check on shell startup
background_dotfiles_check
